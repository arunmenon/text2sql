#!/usr/bin/env python3
"""
Test Enhancement Workflow

Tests the metadata enhancement workflow that creates a business glossary
with proper graph structure.
"""
import os
import sys
import pytest
import asyncio
from unittest.mock import MagicMock, patch

# Add the parent directory to path to allow imports
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from src.text2sql.metadata_enhancement_direct import DirectEnhancementWorkflow
from src.graph_storage.neo4j_client import Neo4jClient
from src.llm.client import LLMClient

# Sample test data
SAMPLE_TABLES = [
    {
        "name": "customers",
        "description": "Contains customer information"
    },
    {
        "name": "orders",
        "description": "Customer orders"
    },
    {
        "name": "products",
        "description": "Available products"
    }
]

SAMPLE_COLUMNS = [
    {
        "name": "customer_id",
        "table_name": "customers",
        "data_type": "INT",
        "description": "Unique identifier for customers"
    },
    {
        "name": "customer_name",
        "table_name": "customers",
        "data_type": "VARCHAR",
        "description": "Customer's full name"
    },
    {
        "name": "order_id",
        "table_name": "orders",
        "data_type": "INT",
        "description": "Unique identifier for orders"
    },
    {
        "name": "customer_id",
        "table_name": "orders",
        "data_type": "INT",
        "description": "Foreign key to customers table"
    },
    {
        "name": "product_id",
        "table_name": "products",
        "data_type": "INT",
        "description": "Unique identifier for products"
    },
    {
        "name": "product_name",
        "table_name": "products",
        "data_type": "VARCHAR",
        "description": "Name of the product"
    }
]

SAMPLE_LLM_RESPONSE = {
    "business_terms": [
        {
            "name": "Customer",
            "definition": "Individual or entity that purchases products or services",
            "technical_mapping": {
                "tables": ["customers"],
                "columns": [{"table": "customers", "column": "customer_id"}]
            },
            "related_terms": ["Order"],
            "synonyms": ["Client", "Patron"]
        },
        {
            "name": "Order",
            "definition": "A request from a customer to purchase products",
            "technical_mapping": {
                "tables": ["orders"],
                "columns": [{"table": "orders", "column": "order_id"}]
            },
            "related_terms": ["Customer", "Product"],
            "synonyms": ["Purchase"]
        }
    ],
    "business_metrics": [
        {
            "name": "Order Count",
            "definition": "Total number of orders placed",
            "derived_from": ["orders"]
        }
    ]
}


class TestEnhancementWorkflow:
    """Test cases for the Direct Enhancement Workflow"""
    
    @pytest.fixture
    def mock_neo4j_client(self):
        """Create a mock Neo4j client for testing"""
        mock_client = MagicMock(spec=Neo4jClient)
        
        # Configure mocks for methods
        mock_client.get_tables_for_tenant.return_value = SAMPLE_TABLES
        mock_client.get_columns_for_table.side_effect = lambda tenant_id, table_name: [
            col for col in SAMPLE_COLUMNS if col["table_name"] == table_name
        ]
        
        return mock_client
    
    @pytest.fixture
    def mock_llm_client(self):
        """Create a mock LLM client for testing"""
        mock_client = MagicMock(spec=LLMClient)
        
        # Configure mock responses
        async def mock_generate_structured_output(*args, **kwargs):
            return SAMPLE_LLM_RESPONSE
        
        async def mock_generate(*args, **kwargs):
            return "Enhanced description generated by the LLM."
        
        mock_client.generate_structured_output.side_effect = mock_generate_structured_output
        mock_client.generate.side_effect = mock_generate
        
        return mock_client
    
    @pytest.fixture
    def enhancement_workflow(self, mock_neo4j_client, mock_llm_client):
        """Create a DirectEnhancementWorkflow instance with mock clients"""
        return DirectEnhancementWorkflow(mock_neo4j_client, mock_llm_client)
    
    @pytest.mark.asyncio
    async def test_enhance_table_descriptions(self, enhancement_workflow):
        """Test enhancing table descriptions"""
        await enhancement_workflow._enhance_table_descriptions("test_tenant", SAMPLE_TABLES)
        
        # Verify that LLM generate was called for each table
        assert enhancement_workflow.llm_client.generate.call_count == len(SAMPLE_TABLES)
        
        # Verify that Neo4j client executed updates
        assert enhancement_workflow.neo4j_client._execute_query.call_count >= len(SAMPLE_TABLES)
    
    @pytest.mark.asyncio
    async def test_generate_normalized_business_glossary(self, enhancement_workflow):
        """Test generating a normalized business glossary"""
        await enhancement_workflow._generate_normalized_business_glossary("test_tenant", "test_dataset", SAMPLE_TABLES)
        
        # Verify LLM was called to generate the glossary
        enhancement_workflow.llm_client.generate_structured_output.assert_called_once()
        
        # Verify that Neo4j client executed the queries to create the glossary
        # At minimum: clear existing glossary, create root node, term nodes, metric nodes
        # plus relationship creation
        expected_min_queries = 3 + len(SAMPLE_LLM_RESPONSE["business_terms"]) + len(SAMPLE_LLM_RESPONSE["business_metrics"])
        assert enhancement_workflow.neo4j_client._execute_query.call_count >= expected_min_queries
    
    @pytest.mark.asyncio
    async def test_full_workflow(self, enhancement_workflow):
        """Test the full enhancement workflow"""
        # Mock the individual component methods to avoid duplicate testing
        with patch.object(enhancement_workflow, '_enhance_table_descriptions') as mock_enhance_tables, \
             patch.object(enhancement_workflow, '_enhance_column_descriptions') as mock_enhance_columns, \
             patch.object(enhancement_workflow, '_generate_normalized_business_glossary') as mock_gen_glossary, \
             patch.object(enhancement_workflow, '_analyze_semantic_relationships') as mock_analyze_relationships, \
             patch.object(enhancement_workflow, '_identify_business_domain') as mock_identify_domain, \
             patch.object(enhancement_workflow, '_generate_concept_tags') as mock_gen_tags, \
             patch.object(enhancement_workflow, '_generate_sample_queries') as mock_gen_queries:
            
            result = await enhancement_workflow.run("test_tenant", "test_dataset")
            
            # Verify all components were called
            mock_enhance_tables.assert_called_once()
            mock_enhance_columns.assert_called_once()
            mock_gen_glossary.assert_called_once()
            mock_analyze_relationships.assert_called_once()
            mock_identify_domain.assert_called_once()
            mock_gen_tags.assert_called_once()
            mock_gen_queries.assert_called_once()
            
            # Verify workflow completion was recorded
            enhancement_workflow.neo4j_client._execute_query.assert_called()
            
            # Verify successful result
            assert result is True


if __name__ == "__main__":
    pytest.main(["-xvs", __file__])